module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _radium = __webpack_require__(3);

	var _radium2 = _interopRequireDefault(_radium);

	var _reactDimensions = __webpack_require__(4);

	var _reactDimensions2 = _interopRequireDefault(_reactDimensions);

	var _EventsBar = __webpack_require__(5);

	var _EventsBar2 = _interopRequireDefault(_EventsBar);

	var _helpers = __webpack_require__(8);

	var _Constants = __webpack_require__(14);

	var _Constants2 = _interopRequireDefault(_Constants);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	// Decorators


	// Components


	// Helpers and constansts


	/**
	 * Default method to convert a date to a string label
	 * @param {string} date The string representation of a date
	 * @return {string} The formatted date string
	 */
	var defaultGetLabel = function defaultGetLabel(date) {
	  return new Date(date).toDateString().substring(4);
	};

	/*
	 * This is the Horizontal Timeline. This component expects an array of dates
	 * just as strings (e.g. 1993-01-01) and layes them horizontaly on the the screen
	 * also expects a callback which is activated when that particular index is
	 * clicked passing that index along
	 */

	var HorizontalTimeline = function (_React$Component) {
	  _inherits(HorizontalTimeline, _React$Component);

	  function HorizontalTimeline() {
	    _classCallCheck(this, HorizontalTimeline);

	    return _possibleConstructorReturn(this, Object.getPrototypeOf(HorizontalTimeline).apply(this, arguments));
	  }

	  _createClass(HorizontalTimeline, [{
	    key: 'render',
	    value: function render() {
	      var props = this.props;

	      if (!props.containerWidth) {
	        //As long as we do not know the width of our container, do not render anything!
	        return false;
	      }

	      // Convert the date strings to actual date objects
	      var dates = props.values.map(function (value) {
	        return new Date(value);
	      });
	      // Calculate the distances for all events
	      var distances = (0, _helpers.cummulativeSeperation)(dates, props.labelWidth, props.minEventPadding, props.maxEventPadding, props.linePadding);

	      // Convert the distances and dates to events
	      var events = distances.map(function (distance, index) {
	        return {
	          distance: distance,
	          label: props.getLabel(props.values[index]),
	          date: props.values[index]
	        };
	      });

	      var visibleWidth = this.props.containerWidth - 80;

	      var totalWidth = Math.max(events[events.length - 1].distance + this.props.linePadding, visibleWidth);

	      var barPaddingRight = 0;
	      var barPaddingLeft = 0;
	      if (!this.props.isOpenEnding) {
	        barPaddingRight = totalWidth - events[events.length - 1].distance;
	      }
	      if (!this.props.isOpenBeginning) {
	        barPaddingLeft = events[0].distance;
	      }

	      return _react2.default.createElement(_EventsBar2.default, {
	        width: props.containerWidth,
	        height: props.containerHeight,
	        events: events,
	        isTouchEnabled: props.isTouchEnabled,
	        totalWidth: totalWidth,
	        visibleWidth: visibleWidth,
	        index: props.index,
	        styles: props.styles,
	        indexClick: props.indexClick,
	        labelWidth: props.labelWidth,
	        fillingMotion: props.fillingMotion,
	        barPaddingRight: barPaddingRight,
	        barPaddingLeft: barPaddingLeft
	      });
	    }
	  }]);

	  return HorizontalTimeline;
	}(_react2.default.Component);

	/**
	 * The expected properties from the parent
	 * @type {Object}
	 */


	/**
	 * The values that the properties will take if they are not provided
	 * by the user.
	 * @type {Object}
	 */
	HorizontalTimeline.defaultProps = {
	  // --- EVENTS ---
	  getLabel: defaultGetLabel,
	  // --- POSITIONING ---
	  minEventPadding: _Constants2.default.MIN_EVENT_PADDING,
	  maxEventPadding: _Constants2.default.MAX_EVENT_PADDING,
	  linePadding: _Constants2.default.TIMELINE_PADDING,
	  labelWidth: _Constants2.default.DATE_WIDTH,
	  // --- STYLING ---
	  styles: {
	    outline: '#dfdfdf',
	    background: '#f8f8f8',
	    foreground: '#7b9d6f'
	  },
	  fillingMotion: {
	    stiffness: 150,
	    damping: 25
	  },
	  slidingMotion: {
	    stiffness: 150,
	    damping: 25
	  },
	  isOpenEnding: true,
	  isOpenBeginning: true,
	  // --- INTERACTION ---
	  isTouchEnabled: true,
	  isKeyboardEnabled: true
	};

	exports.default = (0, _radium2.default)((0, _reactDimensions2.default)({ elementResize: true })(HorizontalTimeline));

/***/ },
/* 2 */
/***/ function(module, exports) {

	module.exports = require("react");

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = require("radium");

/***/ },
/* 4 */
/***/ function(module, exports) {

	module.exports = require("react-dimensions");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _reactMotion = __webpack_require__(6);

	var _Events = __webpack_require__(7);

	var _Events2 = _interopRequireDefault(_Events);

	var _EventLine = __webpack_require__(10);

	var _EventLine2 = _interopRequireDefault(_EventLine);

	var _Faders = __webpack_require__(11);

	var _Faders2 = _interopRequireDefault(_Faders);

	var _HorizontalTimelineButtons = __webpack_require__(13);

	var _HorizontalTimelineButtons2 = _interopRequireDefault(_HorizontalTimelineButtons);

	var _Constants = __webpack_require__(14);

	var _Constants2 = _interopRequireDefault(_Constants);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var EventsBar = function (_React$Component) {
	  _inherits(EventsBar, _React$Component);

	  function EventsBar(props) {
	    _classCallCheck(this, EventsBar);

	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(EventsBar).call(this, props));

	    _initialiseProps.call(_this);

	    _this.state = {
	      position: 0,
	      maxPosition: Math.min(props.visibleWidth - props.totalWidth, 0)
	    };

	    _this.touch = {
	      coors: {
	        x: 0,
	        y: 0
	      },
	      isSwiping: false,
	      started: false,
	      threshold: 3
	    };
	    return _this;
	  }

	  _createClass(EventsBar, [{
	    key: 'componentWillMount',
	    value: function componentWillMount() {
	      document.body.addEventListener('keydown', this.handleKeydown);
	    }
	  }, {
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      document.body.removeEventListener('keydown', this.handleKeydown);
	    }
	  }, {
	    key: 'componentWillReceiveProps',
	    value: function componentWillReceiveProps(props) {
	      var selectedEvent = props.events[props.index];
	      var minVisible = -this.state.position; // Position is always negative!
	      var maxVisible = minVisible + props.visibleWidth;

	      if (selectedEvent.distance > minVisible + 10 && selectedEvent.distance < maxVisible - 10) {
	        //Make sure we are not outside the view
	        this.slideToPosition(this.state.position, props);
	      } else {
	        //Try to center the selected index
	        this.slideToPosition(-(selectedEvent.distance - props.visibleWidth / 2), props);
	      }
	    }

	    /**
	     * Slide the timeline to a specific position. This method wil automatically cap at 0 and the maximum possible position
	     * @param {number} position: The position you want to slide to
	     * @return {undefined} Modifies the value by which we translate the events bar
	     */


	    /**
	     * This method translates the timeline by a certaing amount depending on if the direction passed
	     * is left or right.
	     *
	     * @param {string} direction The direction towards which the timeline will translates
	     * @param {object} the props to use during this calcuation
	     * @return {undefined} Just modifies the value by which we need to translate the events bar in place
	     */

	  }, {
	    key: 'render',
	    value: function render() {
	      var _this2 = this;

	      //  creating an array of list items that have an onClick handler into which
	      //  passing the index of the clicked entity.
	      // NOTE: Improve timeline dates handeling and eventsMinLapse handling
	      var touchEvents = this.props.isTouchEnabled ? {
	        onTouchStart: this.handleTouchStart,
	        onTouchMove: this.handleTouchMove,
	        onTouchEnd: this.handleTouchEnd
	      } : {};

	      // filled value = distane from origin to the selected event
	      var filledValue = this.props.events[this.props.index].distance - this.props.barPaddingLeft;
	      var eventLineWidth = this.props.totalWidth - this.props.barPaddingLeft - this.props.barPaddingRight;

	      return _react2.default.createElement(
	        'div',
	        _extends({
	          style: {
	            width: this.props.width + 'px',
	            height: this.props.height + 'px'
	          }
	        }, touchEvents),
	        _react2.default.createElement(
	          'div',
	          {
	            className: 'events-wrapper',
	            style: {
	              position: 'relative',
	              height: '100%',
	              margin: '0 40px',
	              overflow: 'hidden'
	            }
	          },
	          _react2.default.createElement(
	            _reactMotion.Motion,
	            {
	              style: {
	                X: (0, _reactMotion.spring)(this.state.position, this.slidingMotion)
	              }
	            },
	            function (_ref) {
	              var X = _ref.X;
	              return _react2.default.createElement(
	                'div',
	                {
	                  className: 'events',
	                  style: {
	                    position: 'absolute',
	                    left: 0,
	                    top: 49,
	                    height: 2,
	                    width: _this2.props.totalWidth,
	                    WebkitTransform: 'translate3d(' + X + ', 0, 0)px',
	                    transform: 'translate3d(' + X + 'px, 0, 0)'
	                  }
	                },
	                _react2.default.createElement(_EventLine2.default, {
	                  left: _this2.props.barPaddingLeft,
	                  width: eventLineWidth,
	                  fillingMotion: _this2.props.fillingMotion,
	                  backgroundColor: _this2.props.styles.outline
	                }),
	                _react2.default.createElement(_EventLine2.default, {
	                  left: _this2.props.barPaddingLeft,
	                  width: filledValue,
	                  fillingMotion: _this2.props.fillingMotion,
	                  backgroundColor: _this2.props.styles.foreground
	                }),
	                _react2.default.createElement(_Events2.default, {
	                  events: _this2.props.events,
	                  selectedIndex: _this2.props.index,
	                  styles: _this2.props.styles,
	                  handleDateClick: _this2.props.indexClick,
	                  labelWidth: _this2.props.labelWidth
	                })
	              );
	            }
	          )
	        ),
	        _react2.default.createElement(_Faders2.default, { styles: this.props.styles }),
	        _react2.default.createElement(_HorizontalTimelineButtons2.default, {
	          maxPosition: this.state.maxPosition,
	          position: this.state.position,
	          styles: this.props.styles,
	          updateSlide: this.updateSlide
	        })
	      );
	    }
	  }]);

	  return EventsBar;
	}(_react2.default.Component);

	var _initialiseProps = function _initialiseProps() {
	  var _this3 = this;

	  this.handleKeydown = function (event) {
	    if (_this3.props.isKeyboardEnabled) {
	      if (event.keyCode === _Constants2.default.LEFT_KEY || event.keyCode === _Constants2.default.RIGHT_KEY) {
	        _this3.updateSlide(_Constants2.default.KEYMAP[event.keyCode]);
	      } else if (event.keyCode === _Constants2.default.UP_KEY) {
	        _this3.props.indexClick(Math.min(_this3.props.selectedIndex + 1, _this3.props.events.length - 1));
	      } else if (event.keyCode === _Constants2.default.DOWN_KEY) {
	        _this3.props.indexClick(Math.max(_this3.props.selectedIndex - 1, 0));
	      }
	    }
	  };

	  this.handleTouchStart = function (event) {
	    var touchObj = event.touches[0];

	    _this3.touch.coors.x = touchObj.pageX;
	    _this3.touch.coors.y = touchObj.pageY;
	    _this3.touch.isSwiping = false;
	    _this3.touch.started = true;
	  };

	  this.handleTouchMove = function (event) {
	    if (!_this3.touch.started) {
	      _this3.handleTouchStart(event);
	      return;
	    }

	    var touchObj = event.touches[0];
	    var dx = Math.abs(_this3.touch.coors.x - touchObj.pageX);
	    var dy = Math.abs(_this3.touch.coors.y - touchObj.pageY);

	    var isSwiping = dx > dy && dx > _this3.touch.threshold;

	    if (isSwiping === true || dx > _this3.touch.threshold || dy > _this3.touch.threshold) {
	      _this3.touch.isSwiping = isSwiping;
	      var dX = _this3.touch.coors.x - touchObj.pageX; // amount scrolled
	      _this3.touch.coors.x = touchObj.pageX;
	      _this3.setState({
	        position: _this3.state.position - dX // set new position
	      });
	    }
	    if (_this3.touch.isSwiping !== true) {
	      return;
	    }
	    // Prevent native scrolling
	    event.preventDefault();
	  };

	  this.handleTouchEnd = function (event) {
	    // Make sure we are scrolled to a valid position
	    _this3.slideToPosition(_this3.state.position);
	    _this3.touch.coors.x = 0;
	    _this3.touch.coors.y = 0;
	    _this3.touch.isSwiping = false;
	    _this3.touch.started = false;
	  };

	  this.slideToPosition = function (position) {
	    var props = arguments.length <= 1 || arguments[1] === undefined ? _this3.props : arguments[1];

	    // the width of the timeline component between the two buttons (prev and next)
	    var maxPosition = Math.min(props.visibleWidth - props.totalWidth, 0); // NEVER scroll to the right

	    _this3.setState({
	      position: Math.max(Math.min(0, position), maxPosition),
	      maxPosition: maxPosition
	    });
	  };

	  this.updateSlide = function (direction) {
	    var props = arguments.length <= 1 || arguments[1] === undefined ? _this3.props : arguments[1];

	    //  translate the timeline to the left('next')/right('prev')
	    if (direction === _Constants2.default.RIGHT) {
	      _this3.slideToPosition(_this3.state.position - props.visibleWidth + props.labelWidth, props);
	    } else if (direction === _Constants2.default.LEFT) {
	      _this3.slideToPosition(_this3.state.position + props.visibleWidth - props.labelWidth, props);
	    }
	  };

	  this.centerEvent = function (index) {
	    var props = arguments.length <= 1 || arguments[1] === undefined ? _this3.props : arguments[1];

	    var event = props.events[index];

	    _this3.slideToPosition(-event.distance);
	  };
	};

	exports.default = EventsBar;

/***/ },
/* 6 */
/***/ function(module, exports) {

	module.exports = require("react-motion");

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _helpers = __webpack_require__(8);

	var _TimelineDot = __webpack_require__(9);

	var _TimelineDot2 = _interopRequireDefault(_TimelineDot);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * The markup Information for all the events on the horizontal timeline.
	 *
	 * @param  {object} props The props from parent mainly styles
	 * @return {StatelessFunctionalReactComponent} Markup Information for the fader
	 */
	var EventsBar = function EventsBar(_ref) {
	  var events = _ref.events;
	  var selectedIndex = _ref.selectedIndex;
	  var styles = _ref.styles;
	  var handleDateClick = _ref.handleDateClick;
	  var labelWidth = _ref.labelWidth;
	  return _react2.default.createElement(
	    'ol',
	    {
	      className: 'events-bar',
	      style: {
	        listStyle: 'none'
	      }
	    },
	    events.map(function (event, index) {
	      return _react2.default.createElement(_TimelineDot2.default, {
	        distanceFromOrigin: event.distance,
	        label: event.label,
	        date: event.date,
	        index: index,
	        key: index,
	        onClick: handleDateClick,
	        selected: selectedIndex,
	        styles: styles,
	        labelWidth: labelWidth
	      });
	    })
	  );
	};

	/**
	 * The styles that parent will provide
	 * @type {Object}
	 */
	exports.default = EventsBar;

/***/ },
/* 8 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	/**
	 * This file contains some helper functions which are stateless (provide a pure interface)
	 * and are used by the timeline component.
	 */

	/**
	 * Differance between two dates
	 *
	 * @param  {Date} first Date of the first event
	 * @param  {Date} second Date of the second event
	 * @return {number} Differance between the two dates
	 */
	var daydiff = exports.daydiff = function daydiff(first, second) {
	  return Math.round(second - first);
	};

	/**
	 * Takes a list of lists and zips them together (size should be the same).
	 *
	 * e.g. zip([['row0col0', 'row0col1', 'row0col2'], ['row1col0', 'row1col1', 'row1col2']]);
	 * = [["row0col0","row1col0"], ["row0col1","row1col1"], ["row0col2","row1col2"]]
	 * @param {array} rows An array (of size 2) of arrays (of equal size).
	 * @return {array} An array (of size of either array in param) of arrays (of size 2)
	 */
	var zip = exports.zip = function zip(rows) {
	  return rows[0].map(function (_, c) {
	    return rows.map(function (row) {
	      return row[c];
	    });
	  });
	};

	/**
	 * Determines the minimum and maximum distance between a list of dates
	 * @param {array} dates The array containing all the dates
	 * @return {{min: number, max: number}} The minimum and maximum distances
	 */
	var dateDistanceExtremes = exports.dateDistanceExtremes = function dateDistanceExtremes(dates) {
	  // determine the minimum distance among events
	  var datePairs = zip([dates.slice(0, -1), dates.slice(1)]);
	  var dateDistances = datePairs.map(function (_ref) {
	    var _ref2 = _slicedToArray(_ref, 2);

	    var x = _ref2[0];
	    var y = _ref2[1];
	    return daydiff(x, y);
	  });

	  // return the minimum distance between two dates but considering that all dates
	  // are the same then return the provided minimum seperation.
	  return {
	    min: Math.min.apply(null, dateDistances),
	    max: Math.max.apply(null, dateDistances)
	  };
	};

	/**
	 * Given dates and some bounds returns an array of positioning information w.r.t. some origin for
	 * that set of dates.
	 *
	 * @param {dates} the array containing dates the dates
	 * @param {number} labelWidth The width the label is going to use
	 * @param {number} minEventPadding The minimum padding between events.
	 * @param {number} maxEventPadding The maximum padding between events.
	 * @param {number} startPadding The padding at the beginning of the timeline
	 * @return {array} positioning information for dates from a given origin point
	 */
	// the interface for this function is pure
	var cummulativeSeperation = exports.cummulativeSeperation = function cummulativeSeperation(dates, labelWidth, minEventPadding, maxEventPadding, startPadding) {
	  // using dynamic programming to set up the distance from the origin of the timeline.
	  var distances = new Array(dates.length);
	  distances[0] = startPadding;

	  // Calculating the minimum seperation between events
	  var dateExtremes = dateDistanceExtremes(dates);
	  var datesDiff = dateExtremes.max - dateExtremes.min;
	  var paddingDiff = maxEventPadding - minEventPadding;
	  // const halfLabel = labelWidth / 2;

	  for (var index = 1; index < distances.length; index += 1) {
	    var distance = daydiff(dates[index - 1], dates[index]);
	    // relative spacing according to min and max seperation
	    var seperation = datesDiff === 0 ? maxEventPadding : Math.round((distance - dateExtremes.min) * paddingDiff / datesDiff + minEventPadding);
	    // the distance_from_origin(n) = distance_from_origin(n-1) + distance between n and n - 1.
	    distances[index] = distances[index - 1] + labelWidth + seperation;
	  }
	  return distances;
	};

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _radium = __webpack_require__(3);

	var _radium2 = _interopRequireDefault(_radium);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * The static/non-static styles Information for a single event dot on the timeline
	 */
	var dots = {
	  /**
	   * The style information for the clickable dates that apper floating over the timeline
	   */
	  links: {
	    position: 'absolute',
	    bottom: 0,
	    textAlign: 'center',
	    paddingBottom: 15
	  },
	  /**
	   * The base style information for the event dot that appers exactly on the timeline
	   */
	  base: {
	    position: 'absolute',
	    bottom: -5,
	    height: 12,
	    width: 12,
	    borderRadius: '50%',
	    transition: 'background-color 0.3s, border-color 0.3s',
	    ':hover': {} },
	  /**
	   * future: The style information for the future dot (wrt selected).
	   * @param {object} styles User passed styles ( foreground, background etc info
	   */
	  future: function future(styles) {
	    return {
	      backgroundColor: styles.background,
	      // border: `2px solid ${styles.background}`,
	      border: '2px solid ' + styles.outline
	    };
	  },
	  /**
	   * past: The styles information for the past dot (wrt selected)
	   * @param {object} styles User passed styles ( foreground, background etc info
	   */
	  past: function past(styles) {
	    return {
	      backgroundColor: styles.background,
	      border: '2px solid ' + styles.foreground
	    };
	  },
	  /**
	   * present: The styles information for the preset dot
	   * @param {object} styles User passed styles ( foreground, background etc info
	   */
	  present: function present(styles) {
	    return {
	      backgroundColor: styles.foreground,
	      border: '2px solid ' + styles.foreground
	    };
	  }
	};

	/**
	 * The markup for one single dot on the timeline
	  *
	 * @param {object} props The props passed down
	 * @return {StatelessFunctionalReactComponent} The markup for a dot
	 */

	var TimelineDot = function (_React$Component) {
	  _inherits(TimelineDot, _React$Component);

	  function TimelineDot() {
	    var _Object$getPrototypeO;

	    var _temp, _this, _ret;

	    _classCallCheck(this, TimelineDot);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(TimelineDot)).call.apply(_Object$getPrototypeO, [this].concat(args))), _this), _this.__getDotStyles__ = function (dotType, key) {
	      var hoverStyle = {
	        backgroundColor: _this.props.styles.foreground,
	        border: '2px solid ' + _this.props.styles.foreground
	      };

	      return [dots.base, { left: _this.props.labelWidth / 2 - dots.base.width / 2 }, dots[dotType](_this.props.styles), _radium2.default.getState(_this.state, key, ':hover') || _radium2.default.getState(_this.state, 'dot-dot', ':hover') ? hoverStyle : undefined];
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  _createClass(TimelineDot, [{
	    key: 'render',
	    value: function render() {
	      var _this2 = this;

	      var dotType = 'future';
	      if (this.props.index < this.props.selected) {
	        dotType = 'past';
	      } else if (this.props.index === this.props.selected) {
	        dotType = 'present';
	      }

	      return _react2.default.createElement(
	        'li',
	        {
	          key: this.props.date,
	          id: 'timeline-dot-' + this.props.date,
	          className: dotType + ' dot-label',
	          onClick: function onClick() {
	            return _this2.props.onClick(_this2.props.index);
	          },
	          style: [dots.links, {
	            left: this.props.distanceFromOrigin - this.props.labelWidth / 2,
	            cursor: 'pointer',
	            width: this.props.labelWidth,
	            ':hover': {} }]
	        },
	        this.props.label,
	        _react2.default.createElement('span', {
	          key: 'dot-dot',
	          onClick: function onClick() {
	            return _this2.props.onClick(_this2.props.index);
	          },
	          style: this.__getDotStyles__(dotType, this.props.date)
	        })
	      );
	    }
	  }]);

	  return TimelineDot;
	}(_react2.default.Component);

	/**
	 * propTypes
	 * @type {Object}
	 */


	exports.default = (0, _radium2.default)(TimelineDot);

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _reactMotion = __webpack_require__(6);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * The markup Information for an event Line. You can stack multiple lines on top of eachother
	 *
	 * @param  {object} props The props from parent, styling and positioning
	 * @return {StatelessFunctionalReactComponent} Markup Information for the event line.
	 */
	var EventLine = function EventLine(_ref) {
	  var left = _ref.left;
	  var width = _ref.width;
	  var fillingMotion = _ref.fillingMotion;
	  var backgroundColor = _ref.backgroundColor;
	  return _react2.default.createElement(
	    _reactMotion.Motion,
	    { style: {
	        tWidth: (0, _reactMotion.spring)(width, fillingMotion),
	        tLeft: (0, _reactMotion.spring)(left, fillingMotion)
	      } },
	    function (_ref2) {
	      var tWidth = _ref2.tWidth;
	      var tLeft = _ref2.tLeft;
	      return _react2.default.createElement('span', {
	        'aria-hidden': 'true',
	        className: 'timeline-eventline',
	        style: {
	          position: 'absolute',
	          left: tLeft + 'px',
	          top: 0,
	          height: '100%',
	          width: tWidth + 'px',
	          transformOrigin: 'left center',
	          backgroundColor: backgroundColor
	        }
	      });
	    }
	  );
	};

	exports.default = EventLine;

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _radium = __webpack_require__(3);

	var _radium2 = _interopRequireDefault(_radium);

	var _color = __webpack_require__(12);

	var _color2 = _interopRequireDefault(_color);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var LEFT = 'left';
	var RIGHT = 'right';

	/**
	 * Returns the styles that generate a fading effect on the edges of the timeline
	 *
	 * @param  {object} styles The styles (user-definded/default).Mainly Information about the background, foreground, etc.
	 * @param  {string} position The position of the fader. Can only be left or right
	 * @param  {string} gradientDirection The direction in which we want to generate fade effect
	 * @return {object} The styleing Information for the left or right fader
	 */
	var faderStyle = {
	  base: {
	    top: '50%',
	    position: 'absolute',
	    bottom: 'auto',
	    transform: 'translateY(-50%)',
	    height: '100%',
	    width: 20,
	    overflow: 'hidden'
	  },
	  specific: function specific(styles, position, gradientDirection) {
	    var _ref;

	    return _ref = {}, _defineProperty(_ref, position, 40), _defineProperty(_ref, 'backgroundImage', 'linear-gradient(to ' + gradientDirection + ', ' + styles.background + ', ' + (0, _color2.default)(styles.background).alpha(0).rgbaString() + ')'), _ref;
	  }
	};

	/**
	 * The markup Information for an element that produces the fade effect at the end of the timeline
	 *
	 * @param  {object} props The props from parent mainly styles
	 * @return {StatelessFunctionalReactComponent} Markup Information for the fader
	 */
	var Faders = function Faders(props) {
	  return _react2.default.createElement(
	    'ul',
	    { style: { listStyle: 'none' } },
	    _react2.default.createElement('li', { style: [faderStyle.base, faderStyle.specific(props.styles, LEFT, RIGHT)] }),
	    _react2.default.createElement('li', { style: [faderStyle.base, faderStyle.specific(props.styles, RIGHT, LEFT)] })
	  );
	};

	/**
	 * The styles that parent will provide
	 * @type {Object}
	 */
	exports.default = (0, _radium2.default)(Faders);

/***/ },
/* 12 */
/***/ function(module, exports) {

	module.exports = require("color");

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _radium = __webpack_require__(3);

	var _radium2 = _interopRequireDefault(_radium);

	var _Constants = __webpack_require__(14);

	var _Constants2 = _interopRequireDefault(_Constants);

	var _angleLeft = __webpack_require__(15);

	var _angleLeft2 = _interopRequireDefault(_angleLeft);

	var _angleRight = __webpack_require__(17);

	var _angleRight2 = _interopRequireDefault(_angleRight);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	// icons


	// this handles the rendering part of the buttons that appear on either side of
	// the timeline.

	/**
	 * These are the static styles for the buttons on either side of the timeline.
	 *
	 * @param {styles} styles The user-definded styles/the default styles
	 * @param {boolean} active Hacky crap to get svg filling color right
	 * @return {object} An object containing styles for the buttons
	 * link: styles defined for the link elements i.e. the href tag.
	 * icon: styles defined for the icon that appears on the button.
	 * inactive: styles defined for when the icons are inactive.
	 */
	var buttonStyles = {
	  link: function link(_ref) {
	    var outline = _ref.outline;
	    return {
	      position: 'absolute',
	      top: '49px',
	      bottom: 'auto',
	      transform: 'translateY(-50%)',
	      height: 34,
	      width: 34,
	      borderRadius: '50%',
	      border: '2px solid ' + outline,
	      overflow: 'hidden',
	      textIndent: '100%',
	      whiteSpace: 'nowrap',
	      transition: 'border-color 0.3s'
	    };
	  },
	  icon: function icon(styles, active) {
	    return {
	      position: 'absolute',
	      left: 0,
	      top: '50%',
	      bottom: 'auto',
	      transform: 'translateY(-50%)',
	      height: 20,
	      width: 29,
	      overflow: 'hidden',
	      textIndent: '100%',
	      whiteSpace: 'nowrap',
	      fill: active ? styles.foreground : styles.outline
	    };
	  },
	  inactive: function inactive(styles) {
	    return {
	      color: styles.outline,
	      cursor: 'not-allowed',
	      ':hover': {
	        border: '2px solid ' + styles.outline
	      }
	    };
	  },
	  active: function active(styles) {
	    return {
	      cursor: 'pointer',
	      ':hover': {
	        border: '2px solid ' + styles.foreground,
	        color: styles.foreground
	      }
	    };
	  }
	};

	/**
	 * Markup for both the buttons (that translate the timeline left or right).
	 *
	 * @param  {object} props The info provided by the parent
	 * @return {StatelessFunctionalReactComponent} The Markup info for both the buttons
	 */
	var HorizontalTimelineButtons = function HorizontalTimelineButtons(props) {
	  var buttonBackEnabled = Math.round(props.position) < 0;
	  var buttonForwardEnabled = Math.round(props.position) > Math.round(props.maxPosition);

	  return _react2.default.createElement(
	    'ul',
	    { className: 'buttons' },
	    _react2.default.createElement(
	      'li',
	      {
	        className: 'button-back ' + (buttonBackEnabled ? 'enabled' : 'disabled'),
	        key: _Constants2.default.LEFT,
	        onClick: function onClick() {
	          return props.updateSlide(_Constants2.default.LEFT);
	        },
	        style: [buttonStyles.link(props.styles), buttonBackEnabled ? buttonStyles.active(props.styles) : buttonStyles.inactive(props.styles), _defineProperty({}, _Constants2.default.LEFT, 0)]
	      },
	      _react2.default.createElement(_angleLeft2.default, {
	        style: buttonStyles.icon(props.styles, buttonBackEnabled)
	      })
	    ),
	    _react2.default.createElement(
	      'li',
	      {
	        className: 'button-forward ' + (buttonForwardEnabled ? 'enabled' : 'disabled'),
	        key: _Constants2.default.RIGHT,
	        onClick: function onClick() {
	          return props.updateSlide(_Constants2.default.RIGHT);
	        },
	        style: [buttonStyles.link(props.styles), buttonForwardEnabled ? buttonStyles.active(props.styles) : buttonStyles.inactive(props.styles), _defineProperty({}, _Constants2.default.RIGHT, 0)]
	      },
	      _react2.default.createElement(_angleRight2.default, {
	        style: buttonStyles.icon(props.styles, buttonForwardEnabled)
	      })
	    )
	  );
	};

	// Expected propteries


	// Wrapping the buttons with Radium (so we get all the styling goodness)
	exports.default = (0, _radium2.default)(HorizontalTimelineButtons);

/***/ },
/* 14 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Exporting some constants used in the files
	 * return {object}
	 */
	module.exports = {
	  // Left and right are used to control the direciton in which we want to translate our
	  // timeline
	  LEFT: 'left',
	  RIGHT: 'right',

	  // The keycodes of all the arrow keys (used for keyboard navigation)
	  LEFT_KEY: 37,
	  RIGHT_KEY: 39,
	  UP_KEY: 38,
	  DOWN_KEY: 40,

	  // Milliseconds in a given day (required to set the minimum seperation on events)
	  DAY: 86400000,
	  // Total length of the timeline in pixels
	  MIN_TIMELINE_WIDTH: 750,
	  // Minimum padding between two event labels
	  MIN_EVENT_PADDING: 20,
	  // Maximum padding between two event labels
	  MAX_EVENT_PADDING: 120,
	  // width of the area for text in the timeline
	  DATE_WIDTH: 85,
	  // Padding at end of timeline
	  TIMELINE_PADDING: 100,

	  // which events to trigger based on the left or the right arrow key on the keyboard is pressed
	  KEYMAP: {
	    37: 'left',
	    39: 'right'
	  }
	};

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);
	var IconBase = __webpack_require__(16);

	var FaAngleLeft = function (_React$Component) {
	    _inherits(FaAngleLeft, _React$Component);

	    function FaAngleLeft() {
	        _classCallCheck(this, FaAngleLeft);

	        return _possibleConstructorReturn(this, Object.getPrototypeOf(FaAngleLeft).apply(this, arguments));
	    }

	    _createClass(FaAngleLeft, [{
	        key: 'render',
	        value: function render() {
	            return React.createElement(
	                IconBase,
	                _extends({ viewBox: '0 0 40 40' }, this.props),
	                React.createElement(
	                    'g',
	                    null,
	                    React.createElement('path', { d: 'm26.5 12.1q0 0.3-0.2 0.6l-8.8 8.7 8.8 8.8q0.2 0.2 0.2 0.5t-0.2 0.5l-1.1 1.1q-0.3 0.3-0.6 0.3t-0.5-0.3l-10.4-10.4q-0.2-0.2-0.2-0.5t0.2-0.5l10.4-10.4q0.3-0.2 0.5-0.2t0.6 0.2l1.1 1.1q0.2 0.2 0.2 0.5z' })
	                )
	            );
	        }
	    }]);

	    return FaAngleLeft;
	}(React.Component);

	exports.default = FaAngleLeft;
	module.exports = exports['default'];

/***/ },
/* 16 */
/***/ function(module, exports) {

	module.exports = require("react-icon-base");

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);
	var IconBase = __webpack_require__(16);

	var FaAngleRight = function (_React$Component) {
	    _inherits(FaAngleRight, _React$Component);

	    function FaAngleRight() {
	        _classCallCheck(this, FaAngleRight);

	        return _possibleConstructorReturn(this, Object.getPrototypeOf(FaAngleRight).apply(this, arguments));
	    }

	    _createClass(FaAngleRight, [{
	        key: 'render',
	        value: function render() {
	            return React.createElement(
	                IconBase,
	                _extends({ viewBox: '0 0 40 40' }, this.props),
	                React.createElement(
	                    'g',
	                    null,
	                    React.createElement('path', { d: 'm26.3 21.4q0 0.3-0.2 0.5l-10.4 10.4q-0.3 0.3-0.6 0.3t-0.5-0.3l-1.1-1.1q-0.2-0.2-0.2-0.5t0.2-0.5l8.8-8.8-8.8-8.7q-0.2-0.3-0.2-0.6t0.2-0.5l1.1-1.1q0.3-0.2 0.5-0.2t0.6 0.2l10.4 10.4q0.2 0.2 0.2 0.5z' })
	                )
	            );
	        }
	    }]);

	    return FaAngleRight;
	}(React.Component);

	exports.default = FaAngleRight;
	module.exports = exports['default'];

/***/ }
/******/ ]);